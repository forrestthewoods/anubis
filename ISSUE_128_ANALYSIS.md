# Issue 128 Analysis: Dependency Build Order Bug

## Problem Summary

When building targets with dependencies that generate source files, the build can fail because source compilation jobs start before the dependency jobs complete. This manifests when building `//examples/ffmpeg:ffmpeg` from a clean repository state.

## Reproduction Case

The `ffmpeg_resources` static library demonstrates this issue:

```papyrus
# In examples/ffmpeg/ANUBIS

# Code generator that creates .c files from binary resources
anubis_cmd(
    name = "generate_resources",
    tool = Target(":bin2c"),
    args = [
        [RelPath("...graph.html"), RelPath("...graph.html.c"), "graph_html"],
        [RelPath("...graph.css"), RelPath("...graph.css.c"), "graph_css"],
    ],
)

# Library that compiles the generated .c files
cc_static_library(
    name = "ffmpeg_resources",
    lang = "c",
    srcs = RelPaths([
        "FFmpeg/fftools/resources/graph.html.c",  # Generated by generate_resources
        "FFmpeg/fftools/resources/graph.css.c",   # Generated by generate_resources
    ]),
    deps = Targets([
        ":generate_resources",  # Should complete BEFORE compiling srcs
    ]),
)
```

**Expected behavior:** `generate_resources` completes, creating the `.c` files, then `ffmpeg_resources` compiles them.

**Actual behavior:** Compilation of `.c` files starts in parallel with `generate_resources`, causing "file not found" errors.

## Root Cause

Located in `src/rules/cc_rules.rs`, both `build_cc_binary` (line 356) and `build_cc_static_library` (line 435).

### Current (Buggy) Implementation Pattern

```rust
fn build_cc_static_library(static_library: Arc<CcStaticLibrary>, job: Job) -> JobOutcome {
    let mut child_jobs: Vec<JobId> = Default::default();

    // Step 1: Create jobs for dependencies
    for dep in &static_library.deps {
        let job_id = job.ctx.anubis.build_rule(dep, &job.ctx)?;
        child_jobs.push(job_id);
    }

    // Step 2: BUG - Create compile jobs IMMEDIATELY (not after deps finish!)
    for src in &static_library.srcs {
        let substep = build_cc_file(src.clone(), ...)?;
        child_jobs.push(substep.id);
    }

    // Step 3: Archive waits for ALL child jobs
    let continuation_job = archive_job;
    Ok(JobOutcome::Deferred(JobDeferral {
        blocked_by: child_jobs,  // Archive is blocked correctly
        continuation_job,
    }))
}
```

The issue: Step 2 runs immediately after step 1, creating compile jobs that execute **in parallel** with dependency jobs. If a dependency generates source files, those files won't exist yet.

### Why the Archive Step Works Correctly

The archive/link continuation job uses `JobOutcome::Deferred` with `blocked_by: child_jobs`, which correctly waits for both dependency jobs and compile jobs. The bug is that compile jobs shouldn't be created until dependency jobs complete.

## Correct Pattern: Two-Phase Deferral

The `anubis_cmd` rule (`src/rules/cmd_rules.rs`) already implements this correctly:

```rust
// Phase 1: Wait for tool to build
fn build_anubis_cmd(cmd: Arc<AnubisCmd>, job: Job) -> JobOutcome {
    let tool_job_id = build_rule(&cmd.tool, ...)?;

    Ok(JobOutcome::Deferred(JobDeferral {
        blocked_by: vec![tool_job_id],
        continuation_job: spawn_commands_job,  // Phase 2 runs AFTER tool built
    }))
}

// Phase 2: Now safe to spawn commands (tool exists)
fn spawn_command_jobs(cmd: Arc<AnubisCmd>, tool_job_id: JobId, job: Job) -> JobOutcome {
    for args in &cmd.args {
        let child_job = spawn_child(tool_path, args);
        child_job_ids.push(child_job.id);
    }

    Ok(JobOutcome::Deferred(JobDeferral {
        blocked_by: child_job_ids,
        continuation_job: finalize_job,
    }))
}
```

## Proposed Fix

Refactor cc_rules to use two-phase deferral:

### Phase 1: Build Dependencies Only

```rust
fn build_cc_static_library(static_library: Arc<CcStaticLibrary>, job: Job) -> JobOutcome {
    let mut dep_job_ids: Vec<JobId> = Default::default();

    // Only create dependency jobs
    for dep in &static_library.deps {
        let job_id = job.ctx.anubis.build_rule(dep, &job.ctx)?;
        dep_job_ids.push(job_id);
    }

    // Defer source compilation until deps complete
    let continuation = create_compile_phase_job(static_library, dep_job_ids.clone());

    Ok(JobOutcome::Deferred(JobDeferral {
        blocked_by: dep_job_ids,
        continuation_job: continuation,
    }))
}
```

### Phase 2: Compile Sources (After Dependencies Complete)

```rust
fn compile_sources_phase(
    static_library: Arc<CcStaticLibrary>,
    dep_job_ids: Vec<JobId>,
    job: Job
) -> JobOutcome {
    // NOW safe to compile - all deps (including code generators) are done
    let mut all_child_jobs = dep_job_ids;  // Keep dep IDs for result collection

    for src in &static_library.srcs {
        let substep = build_cc_file(src.clone(), ...)?;
        all_child_jobs.push(substep.id);
    }

    // Defer to archive phase
    Ok(JobOutcome::Deferred(JobDeferral {
        blocked_by: all_child_jobs,
        continuation_job: archive_job,
    }))
}
```

## Implementation Notes

1. **Result propagation works automatically**: The job system's `result_propagation` map handles multi-level deferrals (A -> B -> C), propagating results back to original job IDs.

2. **Preserve dep_job_ids for archive phase**: The archive/link phase needs access to dependency job results to collect library paths. Pass `dep_job_ids` through the phases.

3. **Apply to both rules**: Both `build_cc_binary` and `build_cc_static_library` need this fix.

4. **Edge case - no deps**: If a target has no dependencies, phase 1 can skip directly to phase 2 (compile sources immediately).

## Files to Modify

- `src/rules/cc_rules.rs`:
  - `build_cc_binary` (line 356)
  - `build_cc_static_library` (line 435)
  - Add helper functions for the compile-sources phase

## Testing

After implementing the fix:
1. Clean the build directory
2. Build `//examples/ffmpeg:ffmpeg` from scratch
3. Verify the generated `.c` files are created before compilation attempts
